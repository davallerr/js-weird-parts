
--------------------------------------------------------------------------------------------------------------

SECTION 2

Global Object
- Functions written at the global scope essentially become methods of the global object
  (in browsers, the window object)

Exectution Context
- Performed in 2 phases: creation phase and execution phase

Creation Phase
- Sets up memory space for variables and functions // "hoisting"
- Function in entirety is put in memory space, but variable declarations are not
- Variables are all set up as undefined

Undefined
- A special value to indicate that the variable exists but hasn't been set a value
- Different from error that it "is not defined"
- No memory space set up for variable

JA is Single-Threaded
- One command run at a time
- JS is single-threaded in the way it runs in the browser, but the browser is not
- Browser is doing other things besides running JS

JS is Synchronous
- Run in order, at the time things are requested

Variable Environments
- Where variables live and how they relate to each other in memory

Scope
- Possible for 2 different variables to have same name if they sit in different execution contexts
- Still point to different spaces in memory

Asynchronous
- Other parts of the browser are able to do things while JS is doing its thing
- Event Queue: JS is able to be notified of outside activity and respond to it as directed
- When execution stack is empty, JS can process next event queue and run correspondingly
- JS only looks at event queue when execution stack is totally empty


--------------------------------------------------------------------------------------------------------------

SECTION 3

Primitives
- Undefined: lack of existence, don't se variables to this
  Null: lack of existence, but the one to use when you want to define a variable without a value
  Boolean: true or false
  Number: floating point, always some decimals
  String: sequence of characters
  Symbol: new in es6
- Honorary mention: NaN: cannot be evaluated as a number

Operators
- A special function that uses a unique (simple) syntax
- Takes 2 items and returns 1 item, based on what operator is used
- "Infix" notation

Associativity
- What oder operator functions are called when functions have the same precedence
- Either left-to-right, or right-to-left
  Common math (*/+-) all have left-to-right associativity
  Assignment(=) has right-to-left associativity

Coercion
- Converting a value from one type to another
- JS engine uses context clues of code in some cases other languages would throw an error

Precedence, associativity, and coercion
- Leads the statement (3 < 2 < 1) to return true
  < has left-to-right associativity, and evaluates as false, leaving (false < 1)
  In this case false is coerced to a number, 0, leading to (0 < 1) evaluating as true

Usefulness of coercion
- if(a) {} can be useful to check for existence of "a"
  only runs if "a" is undefined, null, 0, "" or other value that converts to false

Default value for variables
- ES6 has neat thing for providing defaults, but isn't discussed
- var = var || 'default value'
- can use || to provide default value, in case that left side of || doesn't exist (converts to false)

Frameworks/Libraries
- JS links in HTML file are stacked on top of one another and run in sequence like script file
  Can use default values to prevent colliding variables from other frameworks/libraries


--------------------------------------------------------------------------------------------------------------

SECTION 4

Objects
- Object sits in memory, and has properties and methods that also sit in memory, to be referenced

Framework aside: faking namespace
- Namespace is a container for variables and functions
  JS doesn't have namespaces, but can fake it with objects
- Use objects as containers so different variables that need the same name don't collide and overwrite

JSON
- INSPIRED by object literal syntax, but is not the same thing
- Properties have to be wrapped in quotes in JSON, optional in JS
- All JSON syntax is valid object literal syntax, but not all object literal syntax is valid JSON
  JSON is more strict
  Functions cannot be properites (no methods)
- JSON.parse takes JSON string and converts it to an object literal syntax
  This can be assigned to a variable to create an object

Functions are objects

First class functions
- Everything you can do with other types, you can do with functions
- Assign them to variables, pass them around, use them as parameters, assign them on the fly
- Function is a special type of object, with invocable code associated with it as a property

Function statements and expressions
- Expression: a unit of code that results in a value, even if that value isn't assigned to anything
- Statement: unit of code that does work, but doesn't return a value

Value vs reference
- If a variable's primitive value is copied somehow, it will create a distinct copy
  Has its own place in memory
  Further changes to one no longer affect the other
- If a variable's object value is copied, it uses the same reference in memory
  Both point to the same place in memory
  Changes to one will continue to impact the copied reference
- Equals operator sets up a new memory space if object value doesn't already exist

"This"
- When code is invoked, an execution context is created, and "this" keyword is created
- "This" can reference different things depending on how a function is called
  In basic function invocation, "this" points to global object (often window)
  In an object's method, "this" points to the object the method sits inside of
  In an internal function within an object's method, "this" points up to the global object again
- Workaround: in method where "this" points to object, first line "var self = this;"
  Use "self" throughout instead of "this"
  At any point down a scope chain, "self" will always point to the "this" that references the object

  lecture 38